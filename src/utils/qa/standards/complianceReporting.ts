
import type { ComplianceReport } from './types';

export interface ComplianceReportSummary {
  timestamp: Date;
  overallScore: number;
  totalFiles: number;
  complianceDistribution: {
    excellent: number;
    good: number;
    fair: number;
    poor: number;
  };
  topViolations: Array<{
    rule: string;
    count: number;
    severity: string;
  }>;
  trends: {
    scoreChange: number;
    violationChange: number;
    improvementAreas: string[];
  };
  actionItems: Array<{
    priority: 'critical' | 'high' | 'medium' | 'low';
    description: string;
    estimatedEffort: number;
  }>;
}

export class ComplianceReportGenerator {
  static generateExecutiveSummary(reports: ComplianceReport[]): ComplianceReportSummary {
    const totalFiles = reports.length;
    const overallScore = reports.reduce((sum, r) => sum + r.complianceScore, 0) / totalFiles;
    
    // Categorize compliance scores
    const distribution = {
      excellent: 0, // 90-100
      good: 0,      // 80-89
      fair: 0,      // 70-79
      poor: 0       // <70
    };

    reports.forEach(report => {
      const score = report.complianceScore;
      if (score >= 90) distribution.excellent++;
      else if (score >= 80) distribution.good++;
      else if (score >= 70) distribution.fair++;
      else distribution.poor++;
    });

    // Analyze top violations
    const violationCounts = new Map<string, { count: number; severity: string }>();
    
    reports.forEach(report => {
      report.violations.forEach(violation => {
        const existing = violationCounts.get(violation.ruleName) || { count: 0, severity: violation.severity };
        violationCounts.set(violation.ruleName, {
          count: existing.count + 1,
          severity: violation.severity
        });
      });
    });

    const topViolations = Array.from(violationCounts.entries())
      .map(([rule, data]) => ({ rule, count: data.count, severity: data.severity }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    // Generate action items
    const actionItems = this.generateActionItems(reports, topViolations);

    return {
      timestamp: new Date(),
      overallScore,
      totalFiles,
      complianceDistribution: distribution,
      topViolations,
      trends: {
        scoreChange: 0, // Would be calculated from historical data
        violationChange: 0, // Would be calculated from historical data
        improvementAreas: this.identifyImprovementAreas(distribution, topViolations)
      },
      actionItems
    };
  }

  static generateDetailedReport(reports: ComplianceReport[]): string {
    const summary = this.generateExecutiveSummary(reports);
    
    return `
# ðŸ“Š Code Compliance Report
**Generated:** ${summary.timestamp.toISOString()}

## ðŸŽ¯ Executive Summary
- **Overall Compliance Score:** ${summary.overallScore.toFixed(1)}/100
- **Files Analyzed:** ${summary.totalFiles}
- **Quality Distribution:**
  - ðŸŸ¢ Excellent (90-100): ${summary.complianceDistribution.excellent} files
  - ðŸŸ¡ Good (80-89): ${summary.complianceDistribution.good} files  
  - ðŸŸ  Fair (70-79): ${summary.complianceDistribution.fair} files
  - ðŸ”´ Poor (<70): ${summary.complianceDistribution.poor} files

## ðŸš¨ Top Violations
${summary.topViolations.map((v, i) => 
  `${i + 1}. **${v.rule}** (${v.severity}): ${v.count} occurrences`
).join('\n')}

## ðŸ“ˆ Improvement Areas
${summary.trends.improvementAreas.map(area => `- ${area}`).join('\n')}

## âœ… Action Items
${summary.actionItems.map((item, i) => 
  `${i + 1}. **${item.priority.toUpperCase()}:** ${item.description} (Est. ${item.estimatedEffort}h)`
).join('\n')}

## ðŸ“‹ Detailed File Analysis
${reports.map(report => `
### ${report.filePath}
- **Score:** ${report.complianceScore}/100
- **Violations:** ${report.violations.length}
- **Auto-fixes Applied:** ${report.autoFixesApplied}
- **Manual Fixes Needed:** ${report.manualFixesNeeded}

${report.violations.length > 0 ? `**Issues:**
${report.violations.slice(0, 5).map(v => `- Line ${v.line}: ${v.message}`).join('\n')}
${report.violations.length > 5 ? `- ... and ${report.violations.length - 5} more` : ''}` : 'âœ… No violations found'}
`).join('\n')}

---
*Report generated by Compliance Engine v1.0*
    `.trim();
  }

  private static generateActionItems(
    reports: ComplianceReport[], 
    topViolations: Array<{ rule: string; count: number; severity: string }>
  ) {
    const actionItems = [];

    // Critical violations first
    const criticalViolations = topViolations.filter(v => v.severity === 'error');
    if (criticalViolations.length > 0) {
      actionItems.push({
        priority: 'critical' as const,
        description: `Fix ${criticalViolations.reduce((sum, v) => sum + v.count, 0)} critical violations across ${criticalViolations.length} rule types`,
        estimatedEffort: criticalViolations.reduce((sum, v) => sum + v.count, 0) * 0.5
      });
    }

    // Files with poor compliance
    const poorFiles = reports.filter(r => r.complianceScore < 70);
    if (poorFiles.length > 0) {
      actionItems.push({
        priority: 'high' as const,
        description: `Refactor ${poorFiles.length} files with poor compliance scores`,
        estimatedEffort: poorFiles.length * 2
      });
    }

    // Top violation types
    const topViolation = topViolations[0];
    if (topViolation && topViolation.count > 5) {
      actionItems.push({
        priority: 'medium' as const,
        description: `Address recurring "${topViolation.rule}" violations (${topViolation.count} instances)`,
        estimatedEffort: topViolation.count * 0.25
      });
    }

    // Auto-fixable issues
    const autoFixableCount = reports.reduce((sum, r) => 
      sum + r.violations.filter(v => v.autoFixable).length, 0
    );
    
    if (autoFixableCount > 0) {
      actionItems.push({
        priority: 'low' as const,
        description: `Run auto-fix for ${autoFixableCount} automatically fixable violations`,
        estimatedEffort: 0.5
      });
    }

    return actionItems;
  }

  private static identifyImprovementAreas(
    distribution: any, 
    topViolations: Array<{ rule: string; count: number; severity: string }>
  ): string[] {
    const areas = [];

    if (distribution.poor > 0) {
      areas.push(`Focus on improving ${distribution.poor} files with poor compliance`);
    }

    if (topViolations.length > 0) {
      areas.push(`Establish coding guidelines to prevent "${topViolations[0].rule}" violations`);
    }

    if (distribution.excellent < distribution.good + distribution.fair + distribution.poor) {
      areas.push('Increase overall code quality standards across the codebase');
    }

    const criticalCount = topViolations.filter(v => v.severity === 'error').length;
    if (criticalCount > 0) {
      areas.push('Prioritize fixing critical violations to prevent production issues');
    }

    return areas;
  }
}
